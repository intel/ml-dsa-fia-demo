# Copyright (C) 2024 Intel Corporation
# SPDX-License-Identifier: MIT

import numpy as np
from tqdm import trange

from helper import DILITHIUM, PK_FILE_PATH, SK_FILE_PATH, SIG_FILE_PATH, SIGS_FILE_PATH, \
    FAULTY_SIG_FILE_PATH, FAULTY_SIGS_FILE_PATH, S1_HASH_LENGTH, S1_HASH_FILE_PATH, \
    save_pk, save_sk, save_s1_hash, load_sk, save_msg_and_sig, save_msgs_and_sigs, info
from verifier import Verifier


class Signer(Verifier):
    def __init__(self) -> None:
        super().__init__()
        self.generate_keys()

    def generate_keys(self) -> None:
        """
        Generates a Dilithium (public, secret) key pair.

        Returns:
            None.
        """
        self.pk, self._sk = DILITHIUM.keygen()

    def sign(self, msg: bytes) -> bytes:
        """
        Signs the provided message.

        Args:
            msg: The message to be signed.

        Returns:
            The signature of the provided message.
        """
        return DILITHIUM.sign(self._sk, msg)

    @staticmethod
    def __fault_shuffled_y(y: list[int], num_zeros: int = DILITHIUM.l * DILITHIUM.n) -> list[int]:
        """
        Simulates a loop abort fault attack on a shuffled implementation of ExpandMask() in Dilithium.Sign().

        Args:
            y: The vector of polynomials generated by ExpandMask() in Dilithium.Sign() with a shuffling countermeasure. To
            be subjected to the simulated loop abort fault attack.
            num_zeros: The number of zero coefficients the simulated loop abort fault attacker will set in the vector of
            polynomials y.

        Returns:
            A faulted vectors of polynomials y, which is the result of the applying the simulated fault attack on the
            shuffled implementation of ExpandMask() in Dilithium.Sign().
        """
        if num_zeros < 0:
            num_zeros = 0

        rng = np.random.default_rng()
        num_choices = DILITHIUM.n * DILITHIUM.l
        choices = rng.choice(num_choices, size=num_zeros, replace=False)
        for idx in choices:
            poly_idx = idx // DILITHIUM.n
            coeff_idx = idx % DILITHIUM.n
            y.rows[poly_idx][0].coeffs[coeff_idx] = 0
        return y

    @staticmethod
    def __y_zero_count_rejection(y: list[int]) -> bool:
        """
        Simulates a countermeasure for a loop abort fault attack on a shuffled implementation of ExpandMask() in
        Dilithium.Sign().

        Args:
            y: A correct and/or faulted vector of polynomials y.

        Returns:
            Whether the provided vector of polynomials y should be rejected as potentially faulty.
        """
        zero_count = 0

        '''
        Notes:
            * Coefficients of the polynomials in y are sampled from [-DILITHIUM.gamma1, DILITHIUM.gamma1]
            * What is the probability of encountering a 0 coefficient in a not-faulted signature?
            * Set the value of `zero_count_threshold`
        '''
        # Remove or comment
        raise Exception('Step 3: add your solution here')

        # Set the value of `zero_count_threshold`
        zero_count_threshold = DILITHIUM.l * DILITHIUM.k * DILITHIUM.n

        for row in y.rows:
            for p in row:
                zero_count += p.coeffs.count(0)

        if zero_count >= zero_count_threshold:
            info(f'Possible fault detected (number of 0 coefficients in y: actual >= threshold): '
                 f'{zero_count:>4} >= {zero_count_threshold:>4}')
            return True

        return False

    def faulty_sign(self, msg: bytes, num_zeros: int = DILITHIUM.l * DILITHIUM.n, protect: bool = False,
                    fault_detection_check_fn=None) -> bytes:
        """
        Signs the provided message in the presence of a simulated loop abort fault attack.

        Args:
            msg: The message to be signed.
            num_zeros: The number of zero coefficients the simulated loop abort fault attacker will set in the vector of
            polynomials y.
            protect: Whether to protect the sign operation against the simulated loop abort fault attack.
            fault_detection_check_fn: The fault detection function that checks vector y. Used only when protect is
            True. If this parameter is  None, `self.__y_zero_count_rejection` is used.

        Returns:
            A faulty signature.
        """
        sk_bytes = self._sk
        dilithium = DILITHIUM
        m = msg

        if fault_detection_check_fn is None:
            fault_detection_check_fn = self.__y_zero_count_rejection

        '''
        Code from `dilithium-py/dilithium.py` - `Dilithium.sign(self, sk_bytes, m)`.
        Includes a small code addition to simulate and detect fault injection. The addition is marked as below:
            # Demo: added code - begin
            # Added code here
            # Demo: added code - end
        '''

        # unpack the secret key
        rho, K, tr, s1, s2, t0 = dilithium._unpack_sk(sk_bytes)

        # Generate matrix A âˆˆ R^(kxl)
        A = dilithium._expandA(rho, is_ntt=True)

        # Set seeds and nonce (kappa)
        mu = dilithium._h(tr + m, 64)
        kappa = 0
        rho_prime = dilithium._h(K + mu, 64)

        # Precompute NTT representation
        s1.to_ntt()
        s2.to_ntt()
        t0.to_ntt()

        alpha = dilithium.gamma_2 << 1
        while True:
            y = dilithium._expandMask(rho_prime, kappa)

            # Demo: added code: begin
            # Simulate a loop abort fault attack on shuffled sampling of y (ExpandMask): the number of coefficients in y
            # that are set to 0 is `num_zeros`
            y = self.__fault_shuffled_y(y, num_zeros)

            # Countermeasure
            if protect and fault_detection_check_fn(y):
                # Decrease the loop abort fault attack strength by decreasing the number of coefficients in y that are
                # set to 0 (`num_zeros`)
                num_zeros -= 64
                # Repeat signature generation
                continue
            # Demo: added code - end

            y_hat = y.copy_to_ntt()

            # increment the nonce
            kappa += dilithium.l

            w = (A @ y_hat).from_ntt()

            # Extract out both the high and low bits
            w1, w0 = w.decompose(alpha)

            # Create challenge polynomial
            w1_bytes = w1.bit_pack_w(dilithium.gamma_2)
            c_tilde = dilithium._h(mu + w1_bytes, 32)
            c = dilithium._sample_in_ball(c_tilde)

            # Store c in NTT form
            c.to_ntt()

            z = y + s1.scale(c).from_ntt()
            if z.check_norm_bound(dilithium.gamma_1 - dilithium.beta):
                continue

            w0_minus_cs2 = w0 - s2.scale(c).from_ntt()
            if w0_minus_cs2.check_norm_bound(dilithium.gamma_2 - dilithium.beta):
                continue

            c_t0 = t0.scale(c).from_ntt()
            # c_t0.reduce_coefficents()

            if c_t0.check_norm_bound(dilithium.gamma_2):
                continue

            w0_minus_cs2_plus_ct0 = w0_minus_cs2 + c_t0

            h = dilithium._make_hint(w0_minus_cs2_plus_ct0, w1, alpha)

            if dilithium._sum_hint(h) > dilithium.omega:
                continue

            return dilithium._pack_sig(c_tilde, z, h)

    def gen_msgs_and_faulty_sigs(self, num_sigs: int = 10, num_zeros: int = 256) -> tuple[list[bytes], list[bytes]]:
        """
        Generates a list of messages and signs them in the presence of a simulated loop abort fault attack.

        Args:
            num_sigs: The number of signatures to be generated.
            num_zeros: The number of zero coefficients the simulated loop abort fault attacker will set in the vector of
            polynomials y for each signature.

        Returns:
            A list of messages and a list of the corresponding faulty signatures.
        """
        msgs, sigs = [], []

        d = f'Generating {num_sigs} faulty signatures, each with {num_zeros} coefficients in y set to 0'
        for i in trange(num_sigs, desc=d):
            msg = f'Message {i:>6}'.encode()
            sig = self.faulty_sign(msg, num_zeros)
            msgs.append(msg)
            sigs.append(sig)

        return msgs, sigs

    def save_keys(self, pk_file_path: str = PK_FILE_PATH, sk_file_path: str = SK_FILE_PATH,
                  s1_hash_file_path: str = S1_HASH_FILE_PATH) -> None:
        """
        Saves the provided Dilithium (public, secret) key pair to a JSON (JavaScript Object Notation) file.

        Args:
            pk_file_path: The path to and the name of the JSON (JavaScript Object Notation) file where to save the
            provided Dilithium public key.
            sk_file_path: The path to and the name of the JSON (JavaScript Object Notation) file where to save the
            provided Dilithium secret key.
            s1_hash_file_path: The path to and the name of the JSON (JavaScript Object Notation) file where to save the
            hash of secret vector s1.

        Returns:
            None.
        """
        save_pk(self.pk, pk_file_path)
        save_sk(self._sk, sk_file_path)

        _, _, _, s1, _, _ = DILITHIUM._unpack_sk(self._sk)
        s1_bytes = s1.bit_pack_s(DILITHIUM.eta)
        s1_hash = DILITHIUM._h(s1_bytes, S1_HASH_LENGTH)
        save_s1_hash(s1_hash, s1_hash_file_path)

    def load_keys(self, pk_file_path: str = PK_FILE_PATH, sk_file_path: str = SK_FILE_PATH) -> None:
        """
        Loads a Dilithium (public, secret) key pair from a JSON (JavaScript Object Notation) file.

        Args:
            pk_file_path: The path to and the name of the JSON (JavaScript Object Notation) file from where to load a
            Dilithium public key.
            sk_file_path: The path to and the name of the JSON (JavaScript Object Notation) file from where to load a
            Dilithium secret key.

        Returns:
            None.
        """
        super().load_pk(pk_file_path)
        self._sk = load_sk(sk_file_path)

    @staticmethod
    def save_sig(msg, sig: bytes, sig_file_path: str = SIG_FILE_PATH) -> None:
        """
        Saves the provided message and the provided corresponding signature in a JSON (JavaScript Object Notation) file.

        Args:
            msg: The message to be saved to a JSON (JavaScript Object Notation) file.
            sig: The signature to be saved to a JSON (JavaScript Object Notation) file.
            sig_file_path: The path to and the name of the JSON (JavaScript Object Notation) file where to save the
            provided message and the provided signature.

        Returns:
            None.
        """
        save_msg_and_sig(msg, sig, sig_file_path)

    @staticmethod
    def save_msgs_and_sigs(msgs: bytes, sigs: bytes, sigs_file_path: str = SIGS_FILE_PATH):
        """
        Saves the provided list of messages and the provided list of corresponding signatures in a JSON
        (JavaScript Object Notation) file.

        Args:
            msgs: The list of messages to be saved to a JSON (JavaScript Object Notation) file.
            sigs: The list of signatures to be saved to a JSON (JavaScript Object Notation) file.
            sigs_file_path: The path to and the name of the JSON (JavaScript Object Notation) file where to save the
            provided list of messages and the provided list of corresponding signatures.

        Returns:
            None.
        """
        save_msgs_and_sigs(msgs, sigs, sigs_file_path)


if __name__ == '__main__':
    msg1 = b'Message 1'
    msg2 = b'Message 2'
    msg3 = b'Have fun solving this'

    signer = Signer()

    # signer.save_keys()
    # signer.load_keys()

    sig1 = signer.sign(msg1)

    # signer.save_sig(msg1, sig1)
    # msg1, sig1 = signer.load_sig()

    signer.verify(msg1, sig1)
    signer.verify(msg2, sig1)

    # Generate a faulty signature with all coefficients in y set to 0
    # Used by Step 1-A
    # sig3 = signer.faulty_sign(msg3)
    # signer.save_sig(msg3, sig3, FAULTY_SIG_FILE_PATH)
    # msg3, sig3 = signer.load_sig(FAULTY_SIG_FILE_PATH)
    # signer.verify(msg3, sig3)

    # Generate `num_sigs` faulty signatures, each with `num_zeros` coefficients in y set to 0
    # Used by Step 1-B
    # msgs, sigs = signer.gen_msgs_and_faulty_sigs(num_zeros=128)
    # signer.save_msgs_and_sigs(msgs, sigs, FAULTY_SIGS_FILE_PATH)
    # msgs, sigs = signer.load_sigs(FAULTY_SIGS_FILE_PATH)
    # signer.verify_sigs(msgs, sigs)

    # Step 3: Protect `faulty_sign` against this fault attack
    # Step 3: begin
    sig = signer.faulty_sign(msg3, protect=True)
    signer.verify(msg3, sig)
    # Step 3: end
